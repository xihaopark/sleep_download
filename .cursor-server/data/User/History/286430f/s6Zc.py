#!/usr/bin/env python3
"""
ÂÆåÊï¥ÁöÑPhysioNetÁù°Áú†Êï∞ÊçÆÁÆ°ÁêÜÂô® - WgetÁâàÊú¨
ÂäüËÉΩÔºöwget‰∏ãËΩΩ + Dropbox‰∏ä‰º† + ÂÆπÈáèÁÆ°ÁêÜ + Èò≤ÈáçÂ§ç
"""

import os
import subprocess
import time
import threading
import queue
import json
import requests
import shutil
from pathlib import Path

class SleepDataWgetManager:
    def __init__(self):
        # ‰ªéÈÖçÁΩÆÊñá‰ª∂ËØªÂèñ
        try:
            from dropbox_config import PHYSIONET_CONFIG, DROPBOX_CONFIG, DOWNLOAD_CONFIG, UPLOAD_CONFIG
            self.username = PHYSIONET_CONFIG['username']
            self.password = PHYSIONET_CONFIG['password']
            self.upload_folder = DROPBOX_CONFIG['upload_folder']
            self.max_concurrent = DOWNLOAD_CONFIG.get('max_concurrent_downloads', 3)
            self.retry_attempts = DOWNLOAD_CONFIG.get('retry_attempts', 3)
            self.timeout = DOWNLOAD_CONFIG.get('download_timeout', 300)
            self.min_free_gb = DOWNLOAD_CONFIG.get('min_free_space_gb', 5)
            self.delete_after_upload = UPLOAD_CONFIG.get('delete_after_upload', True)
            self.chunk_size = UPLOAD_CONFIG.get('upload_chunk_size', 8*1024*1024)
            
            # ‰ΩøÁî®tokenÁÆ°ÁêÜÂô®Ëé∑ÂèñÊúâÊïàtoken
            self.dropbox_token = self.get_valid_token()
            if not self.dropbox_token:
                print("‚ùå Êó†Ê≥ïËé∑ÂèñÊúâÊïàÁöÑDropbox token")
                exit(1)
                
        except ImportError:
            print("‚ùå Êú™ÊâæÂà∞ÈÖçÁΩÆÊñá‰ª∂")
            exit(1)
        
        # Ë∑ØÂæÑÂíåÊñá‰ª∂
        self.download_dir = Path("download")
        self.download_dir.mkdir(exist_ok=True)
        self.success_log = "download_success.txt"
        self.uploaded_log = "uploaded_files.txt"
        self.failed_log = "failed_downloads.txt"
        
        # ÈòüÂàó
        self.download_queue = queue.Queue()
        self.upload_queue = queue.Queue()
        
        # ÁªüËÆ°
        self.stats = {
            'downloaded': 0, 'uploaded': 0, 'failed': 0, 'skipped': 0,
            'download_size': 0, 'upload_size': 0
        }
        self.stats_lock = threading.Lock()
        
        print(f"üöÄ Áù°Áú†Êï∞ÊçÆÁÆ°ÁêÜÂô® (WgetÁâà) ÂàùÂßãÂåñÂÆåÊàê")
        print(f"üîê Áî®Êà∑: {self.username}")

    def get_valid_token(self):
        """Ëé∑ÂèñÊúâÊïàÁöÑDropbox token"""
        try:
            # Â∞ùËØï‰ΩøÁî®tokenÁÆ°ÁêÜÂô®
            from token_manager import MultiServerTokenManager
            manager = MultiServerTokenManager()
            token_data = manager.get_current_token()
            
            if token_data:
                return token_data['access_token']
            else:
                print("‚ö†Ô∏è  TokenÁÆ°ÁêÜÂô®Êú™ÊâæÂà∞ÊúâÊïàtokenÔºåÂ∞ùËØï‰ªéÈÖçÁΩÆÊñá‰ª∂ËØªÂèñ...")
                # Â§áÁî®ÊñπÊ°àÔºö‰ªéÈÖçÁΩÆÊñá‰ª∂ËØªÂèñ
                from dropbox_config import DROPBOX_CONFIG
                return DROPBOX_CONFIG['access_token']
                
        except Exception as e:
            print(f"‚ö†Ô∏è  TokenÁÆ°ÁêÜÂô®Âä†ËΩΩÂ§±Ë¥•: {e}")
            try:
                # Â§áÁî®ÊñπÊ°àÔºö‰ªéÈÖçÁΩÆÊñá‰ª∂ËØªÂèñ
                from dropbox_config import DROPBOX_CONFIG
                return DROPBOX_CONFIG['access_token']
            except:
                return None

    def load_existing_state(self):
        """Âä†ËΩΩÁé∞ÊúâÁä∂ÊÄÅ"""
        downloaded = set()
        uploaded = set()
        
        if os.path.exists(self.success_log):
            with open(self.success_log, 'r') as f:
                downloaded = {line.strip() for line in f if line.strip()}
        
        if os.path.exists(self.uploaded_log):
            with open(self.uploaded_log, 'r') as f:
                uploaded = {line.strip() for line in f if line.strip()}
        
        local_files = set()
        for file_path in self.download_dir.glob("*"):
            if file_path.is_file() and file_path.suffix in ['.edf', '.tsv', '.atr']:
                if file_path.stat().st_size > 1000:
                    local_files.add(file_path.name)
        
        print(f"üìä Â∑≤‰∏ãËΩΩ: {len(downloaded)}, Â∑≤‰∏ä‰º†: {len(uploaded)}, Êú¨Âú∞: {len(local_files)}")
        return downloaded, uploaded, local_files

    def load_tasks(self):
        """Âä†ËΩΩ‰ªªÂä°"""
        downloaded, uploaded, local_files = self.load_existing_state()
        skip_files = downloaded.union(uploaded).union(local_files)
        
        # Âä†ËΩΩ‰∏ãËΩΩ‰ªªÂä°
        download_tasks = []
        if os.path.exists("list.txt"):
            with open("list.txt", 'r') as f:
                for line in f:
                    line = line.strip()
                    if line and line.startswith('http'):
                        filename = line.split('/')[-1]
                        if filename not in skip_files:
                            download_tasks.append(line)
        
        # Âä†ËΩΩ‰∏ä‰º†‰ªªÂä°
        upload_tasks = []
        for file_path in self.download_dir.glob("*"):
            if file_path.is_file() and file_path.suffix in ['.edf', '.tsv', '.atr']:
                if file_path.stat().st_size > 1000 and file_path.name not in uploaded:
                    upload_tasks.append(file_path)
        
        # ÊåâÂ§ßÂ∞èÊéíÂ∫èÔºå‰ºòÂÖàÂ§ÑÁêÜÂ§ßÊñá‰ª∂
        upload_tasks.sort(key=lambda x: x.stat().st_size, reverse=True)
        
        # Ê∑ªÂä†Âà∞ÈòüÂàó
        for url in download_tasks:
            self.download_queue.put(url)
        for file_path in upload_tasks:
            self.upload_queue.put(file_path)
        
        print(f"üì• ÂæÖ‰∏ãËΩΩ: {len(download_tasks)}, üì§ ÂæÖ‰∏ä‰º†: {len(upload_tasks)}")
        return len(download_tasks), len(upload_tasks)

    def check_disk_space(self):
        """Ê£ÄÊü•Á£ÅÁõòÁ©∫Èó¥"""
        total, used, free = shutil.disk_usage("/")
        free_gb = free / (1024**3)
        usage_percent = (used / total) * 100
        return free_gb, usage_percent

    def download_with_wget(self, url):
        """‰ΩøÁî®wget‰∏ãËΩΩ"""
        filename = url.split('/')[-1]
        file_path = self.download_dir / filename
        
        try:
            print(f"‚¨áÔ∏è  ‰∏ãËΩΩ: {filename}")
            
            cmd = [
                'wget', '-c', '-t', str(self.retry_attempts),
                '--timeout', str(self.timeout),
                '--user', self.username, '--password', self.password,
                '-O', str(file_path), url
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=self.timeout+60)
            
            if result.returncode == 0 and file_path.exists() and file_path.stat().st_size > 1000:
                size = file_path.stat().st_size
                with self.stats_lock:
                    self.stats['downloaded'] += 1
                    self.stats['download_size'] += size
                
                with open(self.success_log, 'a') as f:
                    f.write(f"{filename}\n")
                
                print(f"‚úÖ ‰∏ãËΩΩÂÆåÊàê: {filename} ({size//1024//1024}MB)")
                
                # Â§ßÊñá‰ª∂Á´ãÂç≥Âä†ÂÖ•‰∏ä‰º†ÈòüÂàó
                if size > 50*1024*1024:
                    self.upload_queue.put(file_path)
                
                return True
            else:
                if file_path.exists():
                    file_path.unlink()
                return False
                
        except Exception as e:
            print(f"‚ùå ‰∏ãËΩΩÂ§±Ë¥•: {filename} - {e}")
            if file_path.exists():
                file_path.unlink()
            return False

    def upload_to_dropbox(self, file_path):
        """‰∏ä‰º†Âà∞Dropbox"""
        try:
            filename = file_path.name
            file_size = file_path.stat().st_size
            dropbox_path = f"{self.upload_folder}/{filename}"
            
            print(f"üì§ ‰∏ä‰º†: {filename} ({file_size//1024//1024}MB)")
            
            with open(file_path, 'rb') as f:
                # ÂºÄÂßã‰∏ä‰º†‰ºöËØù
                start_response = requests.post(
                    'https://content.dropboxapi.com/2/files/upload_session/start',
                    headers={
                        'Authorization': f'Bearer {self.dropbox_token}',
                        'Dropbox-API-Arg': json.dumps({}),
                        'Content-Type': 'application/octet-stream'
                    },
                    data=f.read(self.chunk_size),
                    timeout=300
                )
                
                if start_response.status_code != 200:
                    raise Exception(f"ÂºÄÂßã‰∏ä‰º†Â§±Ë¥•: {start_response.status_code}")
                
                session_id = start_response.json()['session_id']
                offset = self.chunk_size
                
                # ‰∏ä‰º†Ââ©‰ΩôÂùó
                while offset < file_size:
                    remaining = file_size - offset
                    current_chunk = min(self.chunk_size, remaining)
                    chunk_data = f.read(current_chunk)
                    
                    if offset + current_chunk < file_size:
                        append_response = requests.post(
                            'https://content.dropboxapi.com/2/files/upload_session/append_v2',
                            headers={
                                'Authorization': f'Bearer {self.dropbox_token}',
                                'Dropbox-API-Arg': json.dumps({
                                    'cursor': {'session_id': session_id, 'offset': offset}
                                }),
                                'Content-Type': 'application/octet-stream'
                            },
                            data=chunk_data,
                            timeout=300
                        )
                        if append_response.status_code != 200:
                            raise Exception(f"Âùó‰∏ä‰º†Â§±Ë¥•: {append_response.status_code}")
                    else:
                        finish_response = requests.post(
                            'https://content.dropboxapi.com/2/files/upload_session/finish',
                            headers={
                                'Authorization': f'Bearer {self.dropbox_token}',
                                'Dropbox-API-Arg': json.dumps({
                                    'cursor': {'session_id': session_id, 'offset': offset},
                                    'commit': {'path': dropbox_path, 'mode': 'add', 'autorename': True}
                                }),
                                'Content-Type': 'application/octet-stream'
                            },
                            data=chunk_data,
                            timeout=300
                        )
                        if finish_response.status_code != 200:
                            raise Exception(f"ÂÆåÊàê‰∏ä‰º†Â§±Ë¥•: {finish_response.status_code}")
                    
                    offset += current_chunk
                    time.sleep(0.1)
            
            # ËÆ∞ÂΩï‰∏ä‰º†ÊàêÂäü
            with open(self.uploaded_log, 'a') as f:
                f.write(f"{filename}\n")
            
            with self.stats_lock:
                self.stats['uploaded'] += 1
                self.stats['upload_size'] += file_size
            
            # Âà†Èô§Êú¨Âú∞Êñá‰ª∂
            if self.delete_after_upload:
                file_path.unlink()
                print(f"‚úÖ ‰∏ä‰º†ÂÆåÊàêÂπ∂Âà†Èô§: {filename}")
            else:
                print(f"‚úÖ ‰∏ä‰º†ÂÆåÊàê: {filename}")
            
            return True
            
        except Exception as e:
            print(f"‚ùå ‰∏ä‰º†Â§±Ë¥•: {file_path.name} - {e}")
            return False

    def download_worker(self):
        """‰∏ãËΩΩÂ∑•‰ΩúÁ∫øÁ®ã"""
        while True:
            try:
                url = self.download_queue.get(timeout=10)
                
                # Ê£ÄÊü•Á£ÅÁõòÁ©∫Èó¥
                free_gb, usage_percent = self.check_disk_space()
                if free_gb < self.min_free_gb:
                    print(f"‚ö†Ô∏è  Á£ÅÁõòÁ©∫Èó¥‰∏çË∂≥ ({free_gb:.1f}GB)ÔºåÊöÇÂÅú‰∏ãËΩΩ")
                    self.download_queue.put(url)
                    time.sleep(30)
                    continue
                
                success = self.download_with_wget(url)
                if not success:
                    with self.stats_lock:
                        self.stats['failed'] += 1
                
                self.download_queue.task_done()
                
            except queue.Empty:
                break
            except Exception as e:
                print(f"‚ùå ‰∏ãËΩΩÁ∫øÁ®ãÈîôËØØ: {e}")

    def upload_worker(self):
        """‰∏ä‰º†Â∑•‰ΩúÁ∫øÁ®ã"""
        while True:
            try:
                file_path = self.upload_queue.get(timeout=10)
                self.upload_to_dropbox(file_path)
                self.upload_queue.task_done()
            except queue.Empty:
                break
            except Exception as e:
                print(f"‚ùå ‰∏ä‰º†Á∫øÁ®ãÈîôËØØ: {e}")

    def monitor_worker(self):
        """ÁõëÊéßÁ∫øÁ®ã"""
        start_time = time.time()
        while True:
            time.sleep(60)
            
            free_gb, usage_percent = self.check_disk_space()
            elapsed = time.time() - start_time
            
            with self.stats_lock:
                download_speed = self.stats['downloaded'] / (elapsed/60) if elapsed > 0 else 0
                upload_speed = self.stats['uploaded'] / (elapsed/60) if elapsed > 0 else 0
                
                print(f"\nüìä Áä∂ÊÄÅÊä•Âëä [{time.strftime('%H:%M:%S')}]:")
                print(f"   Â∑≤‰∏ãËΩΩ: {self.stats['downloaded']} ({self.stats['download_size']//1024//1024//1024:.1f}GB)")
                print(f"   Â∑≤‰∏ä‰º†: {self.stats['uploaded']} ({self.stats['upload_size']//1024//1024//1024:.1f}GB)")
                print(f"   Â§±Ë¥•: {self.stats['failed']} | Ë∑≥Ëøá: {self.stats['skipped']}")
                print(f"   ÈÄüÂ∫¶: ‚¨áÔ∏è{download_speed:.1f}/min ‚¨ÜÔ∏è{upload_speed:.1f}/min")
                print(f"   ÈòüÂàó: ‰∏ãËΩΩ{self.download_queue.qsize()} ‰∏ä‰º†{self.upload_queue.qsize()}")
                print(f"   Á£ÅÁõò: {usage_percent:.1f}% ‰ΩøÁî® ({free_gb:.1f}GB ÂèØÁî®)")
                print("-" * 60)

    def run(self):
        """ËøêË°åÁÆ°ÁêÜÂô®"""
        print("üéØ ÂêØÂä®Áù°Áú†Êï∞ÊçÆÁÆ°ÁêÜÂô® (WgetÁâà)")
        
        download_tasks, upload_tasks = self.load_tasks()
        
        if download_tasks == 0 and upload_tasks == 0:
            print("‚úÖ Ê≤°ÊúâÂæÖÂ§ÑÁêÜ‰ªªÂä°")
            return
        
        # ÂêØÂä®Á∫øÁ®ã
        threads = []
        
        # ‰∏ãËΩΩÁ∫øÁ®ã
        for i in range(self.max_concurrent):
            t = threading.Thread(target=self.download_worker, name=f"Download-{i+1}")
            t.daemon = True
            t.start()
            threads.append(t)
        
        # ‰∏ä‰º†Á∫øÁ®ã
        t = threading.Thread(target=self.upload_worker, name="Upload")
        t.daemon = True
        t.start()
        threads.append(t)
        
        # ÁõëÊéßÁ∫øÁ®ã
        t = threading.Thread(target=self.monitor_worker, name="Monitor")
        t.daemon = True
        t.start()
        threads.append(t)
        
        print(f"üîÑ ÂêØÂä® {len(threads)} ‰∏™Á∫øÁ®ã")
        
        try:
            # Á≠âÂæÖÂÆåÊàê
            self.download_queue.join()
            self.upload_queue.join()
            
            print("\nüéâ ÊâÄÊúâ‰ªªÂä°ÂÆåÊàêÔºÅ")
            
            with self.stats_lock:
                print(f"üìä ÊúÄÁªàÁªüËÆ°:")
                print(f"   ‰∏ãËΩΩ: {self.stats['downloaded']} ‰∏™Êñá‰ª∂ ({self.stats['download_size']//1024//1024//1024:.2f}GB)")
                print(f"   ‰∏ä‰º†: {self.stats['uploaded']} ‰∏™Êñá‰ª∂ ({self.stats['upload_size']//1024//1024//1024:.2f}GB)")
                print(f"   Â§±Ë¥•: {self.stats['failed']} ‰∏™Êñá‰ª∂")
        
        except KeyboardInterrupt:
            print("\n‚èπÔ∏è  Áî®Êà∑‰∏≠Êñ≠")
        except Exception as e:
            print(f"\n‚ùå ËøêË°åÈîôËØØ: {e}")

if __name__ == "__main__":
    manager = SleepDataWgetManager()
    manager.run() 